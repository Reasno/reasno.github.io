<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>NestJS on Garbage Collected</title>
    <link>https://guxi.me/tags/nestjs/</link>
    <description>Recent content in NestJS on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Jan 2020 16:04:50 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/tags/nestjs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why You Should Avoid Using Request-scoped Injection in NestJS</title>
      <link>https://guxi.me/posts/why-you-should-avoid-using-request-scope-injection-in-nest-js/</link>
      <pubDate>Wed, 22 Jan 2020 16:04:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/why-you-should-avoid-using-request-scope-injection-in-nest-js/</guid>
      <description>NestJS 6 comes with all-new injection scope support. Namely, instead of enforcing every object managed by DI container to be a singleton, you can now freely assign three types of injection scope to them: singleton, request, and transient.
We adopted the request-scoped injection in our project to achieve distributed tracing as well as context-aware logging. The result turned out to be not so great.
For starters, the request-scoped injection is way too expensive.</description>
    </item>
    
  </channel>
</rss>