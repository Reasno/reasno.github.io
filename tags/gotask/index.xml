<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gotask on Garbage Collected</title>
    <link>https://guxi.me/tags/gotask/</link>
    <description>Recent content in gotask on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Mar 2020 18:34:28 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/tags/gotask/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用Hyperf插入100万行数据到MongoDB，能行吗</title>
      <link>https://guxi.me/posts/hyperf-swoole-gotask/</link>
      <pubDate>Fri, 27 Mar 2020 18:34:28 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-swoole-gotask/</guid>
      <description>得益于优秀的框架设计和超凡的性能，使用Hyperf/Swoole的开发体验非常愉悦。就比如说Hyperf的AOP切面实现吧，曾几何时我为了做jaeger分布式追踪搞了一个很复杂的动态代理，但是后来惊喜的发现在Hyperf框架中用语法树重写在不损一毫秒的情况下就轻松解决了。
不过，也有几次睡不着觉的时候，基本都是因为生态的问题。
一方面，很多C扩展，比如Mongodb，还有我们广告系统经常用的Cassandra扩展，都不能支持协程。另一方面，还有很多PHP原生库充斥着静态变量，一不小心就协程混淆。
要填补上生态上的差距还需要很长时间的努力。目前Swoole有个Task机制，不支持协程的都扔给它去处理。
 在php-fpm的应用中，经常会将一个任务异步投递到Redis等队列中，并在后台启动一些php进程异步地处理这些任务。Swoole提供的TaskWorker是一套更完整的方案，将任务的投递、队列、php任务处理进程管理合为一体。通过底层提供的API可以非常简单地实现异步任务的处理。另外TaskWorker还可以在任务执行完成后，再返回一个结果反馈到Worker。
 这个概念很好理解，Unix Socket的投递速度也是杠杠的。Task类似队列机制，本身有一种削峰填谷的功效，但是再长的缓冲区也毕竟是有限的，如果压力持续走高一样会反噬worker。所以task很难成为常规武器，偶尔用用还可以。
人一旦习惯了epoll，对阻塞IO真的是很难容忍。
有时我在想，实在不行，我就写个Nodejs服务，把查mongodb放到nodejs里，然后PHP再调nodejs接口算了，这总不阻塞了吧。
理想虽然如此，但却一直没有动手写。原因也很简单，强行把一套服务拆成两套，再搞什么限流熔断监控追踪组合拳，着实是给自己找麻烦。
算了，所以还是用Task吧。但是这个Task如果用别的语言来实现，是不是可以更快一点？
在Swoole协程普及后，Swoole的TaskWorker一般来说承担三个责任：
 遇到CPU密集型的操作，扔进来。 遇到暂时无法协程化的IO操作（如MongoDB），扔进来。 遇到某些组件不支持协程，扔进来。  前两条TaskWorker能做的，Go都可以做的更好。第三条嘛，虽然放弃了PHP生态比较遗憾，但是可以接入Go生态也不错。
最近用go搞了一个swoole的边车。是真的边车，用swoole process启动的。挂载到swoole server上跑，swoole起它起，swoole停它停，中间如果go挂了swoole还负责给拉起来。消息投递也照搬swoole task走IPC，从web worker上直接投递，等结果出来再返还web worker。
当然是0阻塞，PHP这边用swoole coroutine socket实现的，每次投递都会触发协程切换。写完再用Hyperf整了一套连接池，全局一个单例注入进来就可以IPC了。
简单示意就是这样：
package main import ( &amp;#34;github.com/reasno/gotask/pkg/gotask&amp;#34; ) // App sample type App struct{} // Hi returns greeting message. func (a *App) Hi(name interface{}, r *interface{}) error { *r = map[string]interface{}{ &amp;#34;hello&amp;#34;: name, } return nil } func main() { gotask.Register(new(App)) gotask.Run() }&amp;lt;?</description>
    </item>
    
  </channel>
</rss>