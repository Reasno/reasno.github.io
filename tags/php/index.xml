<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on Garbage Collected</title>
    <link>https://guxi.me/tags/php/</link>
    <description>Recent content in PHP on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Apr 2020 11:15:31 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/tags/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Swoole pattern: 可中断的睡眠</title>
      <link>https://guxi.me/posts/interrupted-sleep/</link>
      <pubDate>Wed, 08 Apr 2020 11:15:31 +0800</pubDate>
      
      <guid>https://guxi.me/posts/interrupted-sleep/</guid>
      <description>前置阅读：linux信号表
 假设我们有一个监控任务，每5秒钟将监控结果上报。
$buffer = []; // 另一个协程在填充buffer go(function(){ while (true) { sleep(5); sendBatch($buffer); } })  也可以使用Swoole Timer实现，这里先略过。
 那么问题来了，如果我们现在需要关闭服务，如何保证关闭前最后一批数据不丢失？
正常情况下，类unix系统，以及Kubernetes都会先给发送SIGTERM信号提示进程退出。我们的程序如果是个好好先生，就应该听从操作系统的劝告，立刻执行收尾工作并退出。如果程序拒不退出，那么操作系统可以发送强制关闭的信号。SIGINT(control-c)、SIGKILL信号这两个信号都属于“强制关闭”。
在Kuberentes下，总是先发送SIGTERM，如果在一定时间内（默认30s）进程还没有结束，就会SIGKILL。
我们要做的事，就是在收到SIGTERM时，及时把最后一批数据上报并退出。
$exited = false; $server-&amp;gt;on(&amp;#39;workerExit&amp;#39;, function() use ($exited) { $exited = true; }); go(function() use ($exited) { while (true) { sleep(5); sendBatch($buffer); if ($exited) { break; } } }) 对上述程序这样修改，可以保证总是上报完最后一批时结束协程，然后退出。
然而细心的同学会发现这样还有两个潜在的问题。
 程序总是要完成最后一次睡眠后才退出，不是很及时。 如果睡眠时间大于操作系统或用户容忍的时间，仍然有可能被杀掉进程丢失最后一次上报。  事实上，我们需要的是可以中断的睡眠。当收到SIGTERM时，立刻醒来上报最后一次并退出。在传统同步编程或Callback编程中，这个不太好实现，但是在CSP编程中，可以说时一个经典Pattern。
$exited = new Channel(); $server-&amp;gt;on(&amp;#39;workerExit&amp;#39;, function() use ($exited) { go(function() use ($exited){ $exited-&amp;gt;close(); }); }); go(function() use ($exited) { while (true) { $exited-&amp;gt;pop(5); sendBatch($buffer); if ($exited-&amp;gt;errCode === SWOOLE_CHANNEL_CLOSED) { break; } } }) 我们完全没有改变编程逻辑，只是巧妙的利用的channel，就实现了可唤醒的睡眠。这里用了关闭channel来代表睡眠被唤醒，使得多个协程可以复用这个channel来监听结束信号。</description>
    </item>
    
    <item>
      <title>云原生Hyperf骨架包</title>
      <link>https://guxi.me/posts/cloudnative-hyperf/</link>
      <pubDate>Sat, 14 Dec 2019 16:27:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/cloudnative-hyperf/</guid>
      <description>2020-01-22 日更新：现已提供Hyperf Helm chart。详见repo。
 Hyperf官方提供了容器镜像，配置选项又非常开放，将Hyperf部署于云端本身并不复杂。下面我们以Kubernetes为例，对Hyperf默认的骨架包进行一些改造，使它可以优雅的运行于Kubernetes上。本文不是Kubernetes的入门介绍，需要读者已经对Kubernetes有一定了解。
生命周期 容器在Kubernetes上启动以后，Kubernetes会对容器进行两项检查: Liveness Probe和Readiness Probe。Liveness Probe如果没有通过，容器会被重启，而Readiness Probe没有通过，则会暂时将服务从发现列表中移除。当Hyperf作为HTTP Web server启动时，我们只需要添加两条路由就行了。
&amp;lt;?php namespace App\Controller; class HealthCheckController extends AbstractController { public function liveness() { return &amp;#39;ok&amp;#39;; } public function readiness() { return &amp;#39;ok&amp;#39;; } } &amp;lt;?php // in config/Routes.php Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/liveness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@liveness&amp;#39;); Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/readiness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@readiness&amp;#39;);  在Kubernetes的deployment上配置：
livenessProbe:httpGet:path:/livenessport:9501failureThreshold:1periodSeconds:10readinessProbe:httpGet:path:/readinessport:9501failureThreshold:1periodSeconds:10 当然这里我们只是简单了返回‘ok’，显然不能真正检查出健康状况。实际的检查要考虑业务具体场景和业务依赖的资源。例如对于重数据库服务我们可以检查数据库的连接池，如果连接池已满就暂时在Readiness Probe返回状态码503。
服务在Kubernetes销毁时，Kubernetes会先发来SIGTERM信号。进程有terminationGracePeriodSeconds这么长的时间（默认60秒）来自行结束。如果到时间后还没结束，Kubernetes就会发来SIGINT信号来强制杀死进程。Swoole本身是可以正确响应SIGTERM结束服务的，正常情况下不会丢失任何运行中的连接。实际生产中，如果Swoole没有响应SIGTERM退出，很有可能是因为服务端注册的定时器没有被清理。我们可以在OnWorkerExit处清理定时器来保证顺利退出。
&amp;lt;?php // config/autoload/server.php // ... &amp;#39;callbacks&amp;#39; =&amp;gt; [ SwooleEvent::ON_BEFORE_START =&amp;gt; [Hyperf\Framework\Bootstrap\ServerStartCallback::class, &amp;#39;beforeStart&amp;#39;], SwooleEvent::ON_WORKER_START =&amp;gt; [Hyperf\Framework\Bootstrap\WorkerStartCallback::class, &amp;#39;onWorkerStart&amp;#39;], SwooleEvent::ON_PIPE_MESSAGE =&amp;gt; [Hyperf\Framework\Bootstrap\PipeMessageCallback::class, &amp;#39;onPipeMessage&amp;#39;], SwooleEvent::ON_WORKER_EXIT =&amp;gt; function () { Swoole\Timer::clearAll(); }, ], // .</description>
    </item>
    
    <item>
      <title>Hyperf 注解整洁之道</title>
      <link>https://guxi.me/posts/hyperf-clean-annotations/</link>
      <pubDate>Sat, 02 Nov 2019 21:21:14 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-clean-annotations/</guid>
      <description>注解是元编程的一种。元编程从字面意思上说就是编写程序的程序。和普通编程一样，注解在给我们带来便捷的同时，如果使用不当，也有可能造成可读性、可维护性下降等问题。
在某些注解中，可能有很多配置项，比如：
//这还不是一个特别夸张的例子 @CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) 如果我们的代码里用很多这样复杂的注解，就会引发以下几个问题：
 注解中可使用的数据类型表达能力有限，比如必须用方法的字符串全名来表达方法，容易出错。 离开了IDE的帮助，长注解的可读性变得很差。（比如在GitHub上） 同样配置的注解多个地方使用，修改时要改很多地方。  这里我向大家推荐通过继承的方式配置Hyperf内的注解。
下面是一个继承CircuitBreaker（熔断器）注解的例子。
&amp;lt;?php ... /** * @Annotation * @Target({&amp;#34;METHOD&amp;#34;}) * * Shorthand for CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) */ class FooCircuitBreakerAnnotation extends CircuitBreakerAnnotation { /** * @var float */ public $timeout = 0.05; /** * @var string */ public $fallback = UserService::class.&amp;#39;::searchFallback&amp;#39;; /** * The counter required to reset to a close state. * @var int */ public $successCounter = 1; /** * The counter required to reset to a open state.</description>
    </item>
    
    <item>
      <title>Purposed PHP Dialect: P&#43;&#43;</title>
      <link>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</link>
      <pubDate>Mon, 12 Aug 2019 08:26:23 +0800</pubDate>
      
      <guid>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</guid>
      <description>The first time I saw P++ my reaction was &amp;ldquo;meh, it is not going anywhere&amp;rdquo;. Anything breaks backward compatibility and abandons existing user base will get punished eventually. Python community took a decade to heal from the wound caused by Python3. In short, I believe it is not worth it to trade backward compatibility for language design purity. I also wrote a blog about Vue3 changes on its new functional APIs.</description>
    </item>
    
    <item>
      <title>Unboxing Taylor Otwell&#39;s Laravel Cloud</title>
      <link>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</link>
      <pubDate>Tue, 06 Aug 2019 21:39:20 +0800</pubDate>
      
      <guid>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</guid>
      <description>Taylor Otwell, the author of Laravel, recently put up a public copy of his unfinished work Laravel Cloud in GitHub. It was taken down by himself briefly after, due to what he described as &amp;ldquo;too much BS&amp;rdquo;. Forks are still available everywhere though. Here is my fork.
I cloned the repository and skimmed through most of the classes. Here are my takeaways.
 Dependency Injection is used very lightly. The service container is mostly underfilled.</description>
    </item>
    
    <item>
      <title>Contextual Dependency Injection Is a Myth</title>
      <link>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</link>
      <pubDate>Mon, 05 Aug 2019 23:11:10 +0800</pubDate>
      
      <guid>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</guid>
      <description>Sometimes in your daily programming life, you would want to inject different object instances based on the current route or module. For example, you want to connect to Database Foo for route /foo and Database Bar for route /bar. It seems a clever idea to do what is called a &amp;ldquo;contextual binding&amp;rdquo;, aka inject instances conditionally based on some runtime value.
In Laravel it looks like this:
&amp;lt;?php $this-&amp;gt;app-&amp;gt;when(PhotoController::class) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;local&amp;#39;); }); $this-&amp;gt;app-&amp;gt;when([VideoController::class, UploadController::class]) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;s3&amp;#39;); });  This code looks nice and handy at first glance, but in my experience, they are often doing more harm than any good.</description>
    </item>
    
    <item>
      <title>Never Force Yourself to Learn New Skills Without a Concrete Project</title>
      <link>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</link>
      <pubDate>Sun, 28 Jul 2019 13:51:45 +0800</pubDate>
      
      <guid>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</guid>
      <description>As the job demand is going nowhere in a decade, a lot of new guys want to get into programming. There are numerous courses online, teaching a variety of skills in programming. There are also new shinning frameworks climbing up GitHub trending every day. I see a lot of people, typically newly graduated students, get confused. There seems to be an endless stream of knowledge to learn. How many skills are enough?</description>
    </item>
    
    <item>
      <title>When Do We Need PHP</title>
      <link>https://guxi.me/posts/when-do-we-need-php/</link>
      <pubDate>Thu, 18 Jul 2019 12:57:59 +0800</pubDate>
      
      <guid>https://guxi.me/posts/when-do-we-need-php/</guid>
      <description>When we started huijiwiki.com, PHP was the language of the choice. But it was not much a choice. MediaWiki was coded in PHP. It provided us a solid starting point to expand our idea.
Since then I have touched many languages and am moderately proficient in some of them. Among them, Go is my current favorite. Rust is the language I want to explore more.
Go as well as Rust has a very different nature compared to PHP.</description>
    </item>
    
  </channel>
</rss>