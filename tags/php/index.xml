<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on Garbage Collected</title>
    <link>https://guxi.me/tags/php/</link>
    <description>Recent content in PHP on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Dec 2019 16:27:50 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/tags/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>云原生Hyperf骨架包</title>
      <link>https://guxi.me/posts/cloudnative-hyperf/</link>
      <pubDate>Sat, 14 Dec 2019 16:27:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/cloudnative-hyperf/</guid>
      <description>Hyperf官方提供了容器镜像，配置选项又非常开放，将Hyperf部署于云端本身并不复杂。下面我们以Kubernetes为例，对Hyperf默认的骨架包进行一些改造，使它可以优雅的运行于Kubernetes上。本文不是Kubernetes的入门介绍，需要读者已经对Kubernetes有一定了解。
生命周期 容器在Kubernetes上启动以后，Kubernetes会对容器进行两项检查: Liveness Probe和Readiness Probe。Liveness Probe如果没有通过，容器会被重启，而Readiness Probe没有通过，则会暂时将服务从发现列表中移除。当Hyperf作为HTTP Web server启动时，我们只需要添加两条路由就行了。
&amp;lt;?php namespace App\Controller; class HealthCheckController extends AbstractController { public function liveness() { return &amp;#39;ok&amp;#39;; } public function readiness() { return &amp;#39;ok&amp;#39;; } } &amp;lt;?php // in config/Routes.php Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/liveness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@liveness&amp;#39;); Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/readiness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@readiness&amp;#39;);  在Kubernetes的deployment上配置：
livenessProbe:httpGet:path:/livenessport:9501failureThreshold:1periodSeconds:10readinessProbe:httpGet:path:/readinessport:9501failureThreshold:1periodSeconds:10 当然这里我们只是简单了返回‘ok’，显然不能真正检查出健康状况。实际的检查要考虑业务具体场景和业务依赖的资源。例如对于重数据库服务我们可以检查数据库的连接池，如果连接池已满就暂时在Readiness Probe返回状态码503。
服务在Kubernetes销毁时，Kubernetes会先发来SIGTERM信号。进程有terminationGracePeriodSeconds这么长的时间（默认60秒）来自行结束。如果到时间后还没结束，Kubernetes就会发来SIGINT信号来强制杀死进程。Swoole本身是可以正确响应SIGTERM结束服务的，正常情况下不会丢失任何运行中的连接。实际生产中，如果Swoole没有响应SIGTERM退出，很有可能是因为服务端注册的定时器没有被清理。我们可以在OnWorkerExit处清理定时器来保证顺利退出。
&amp;lt;?php // config/autoload/server.php // ... &amp;#39;callbacks&amp;#39; =&amp;gt; [ SwooleEvent::ON_BEFORE_START =&amp;gt; [Hyperf\Framework\Bootstrap\ServerStartCallback::class, &amp;#39;beforeStart&amp;#39;], SwooleEvent::ON_WORKER_START =&amp;gt; [Hyperf\Framework\Bootstrap\WorkerStartCallback::class, &amp;#39;onWorkerStart&amp;#39;], SwooleEvent::ON_PIPE_MESSAGE =&amp;gt; [Hyperf\Framework\Bootstrap\PipeMessageCallback::class, &amp;#39;onPipeMessage&amp;#39;], SwooleEvent::ON_WORKER_EXIT =&amp;gt; function () { Swoole\Timer::clearAll(); }, ], // .</description>
    </item>
    
    <item>
      <title>Hyperf 注解整洁之道</title>
      <link>https://guxi.me/posts/hyperf-clean-annotations/</link>
      <pubDate>Sat, 02 Nov 2019 21:21:14 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-clean-annotations/</guid>
      <description>注解是元编程的一种。元编程从字面意思上说就是编写程序的程序。和普通编程一样，注解在给我们带来便捷的同时，如果使用不当，也有可能造成可读性、可维护性下降等问题。
在某些注解中，可能有很多配置项，比如：
//这还不是一个特别夸张的例子 @CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) 如果我们的代码里用很多这样复杂的注解，就会引发以下几个问题：
 注解中可使用的数据类型表达能力有限，比如必须用方法的字符串全名来表达方法，容易出错。 离开了IDE的帮助，长注解的可读性变得很差。（比如在GitHub上） 同样配置的注解多个地方使用，修改时要改很多地方。  这里我向大家推荐通过继承的方式配置Hyperf内的注解。
下面是一个继承CircuitBreaker（熔断器）注解的例子。
&amp;lt;?php ... /** * @Annotation * @Target({&amp;#34;METHOD&amp;#34;}) * * Shorthand for CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) */ class FooCircuitBreakerAnnotation extends CircuitBreakerAnnotation { /** * @var float */ public $timeout = 0.05; /** * @var string */ public $fallback = UserService::class.&amp;#39;::searchFallback&amp;#39;; /** * The counter required to reset to a close state. * @var int */ public $successCounter = 1; /** * The counter required to reset to a open state.</description>
    </item>
    
    <item>
      <title>Purposed PHP Dialect: P&#43;&#43;</title>
      <link>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</link>
      <pubDate>Mon, 12 Aug 2019 08:26:23 +0800</pubDate>
      
      <guid>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</guid>
      <description>The first time I saw P++ my reaction was &amp;ldquo;meh, it is not going anywhere&amp;rdquo;. Anything breaks backward compatibility and abandons existing user base will get punished eventually. Python community took a decade to heal from the wound caused by Python3. In short, I believe it is not worth it to trade backward compatibility for language design purity. I also wrote a blog about Vue3 changes on its new functional APIs.</description>
    </item>
    
    <item>
      <title>Unboxing Taylor Otwell&#39;s Laravel Cloud</title>
      <link>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</link>
      <pubDate>Tue, 06 Aug 2019 21:39:20 +0800</pubDate>
      
      <guid>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</guid>
      <description>Taylor Otwell, the author of Laravel, recently put up a public copy of his unfinished work Laravel Cloud in GitHub. It was taken down by himself briefly after, due to what he described as &amp;ldquo;too much BS&amp;rdquo;. Forks are still available everywhere though. Here is my fork.
I cloned the repository and skimmed through most of the classes. Here are my takeaways.
 Dependency Injection is used very lightly. The service container is mostly underfilled.</description>
    </item>
    
    <item>
      <title>Contextual Dependency Injection Is a Myth</title>
      <link>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</link>
      <pubDate>Mon, 05 Aug 2019 23:11:10 +0800</pubDate>
      
      <guid>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</guid>
      <description>Sometimes in your daily programming life, you would want to inject different object instances based on the current route or module. For example, you want to connect to Database Foo for route /foo and Database Bar for route /bar. It seems a clever idea to do what is called a &amp;ldquo;contextual binding&amp;rdquo;, aka inject instances conditionally based on some runtime value.
In Laravel it looks like this:
&amp;lt;?php $this-&amp;gt;app-&amp;gt;when(PhotoController::class) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;local&amp;#39;); }); $this-&amp;gt;app-&amp;gt;when([VideoController::class, UploadController::class]) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;s3&amp;#39;); });  This code looks nice and handy at first glance, but in my experience, they are often doing more harm than any good.</description>
    </item>
    
    <item>
      <title>Never Force Yourself to Learn New Skills Without a Concrete Project</title>
      <link>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</link>
      <pubDate>Sun, 28 Jul 2019 13:51:45 +0800</pubDate>
      
      <guid>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</guid>
      <description>As the job demand is going nowhere in a decade, a lot of new guys want to get into programming. There are numerous courses online, teaching a variety of skills in programming. There are also new shinning frameworks climbing up GitHub trending every day. I see a lot of people, typically newly graduated students, get confused. There seems to be an endless stream of knowledge to learn. How many skills are enough?</description>
    </item>
    
    <item>
      <title>When Do We Need PHP</title>
      <link>https://guxi.me/posts/when-do-we-need-php/</link>
      <pubDate>Thu, 18 Jul 2019 12:57:59 +0800</pubDate>
      
      <guid>https://guxi.me/posts/when-do-we-need-php/</guid>
      <description>When we started huijiwiki.com, PHP was the language of the choice. But it was not much a choice. MediaWiki was coded in PHP. It provided us a solid starting point to expand our idea.
Since then I have touched many languages and am moderately proficient in some of them. Among them, Go is my current favorite. Rust is the language I want to explore more.
Go as well as Rust has a very different nature compared to PHP.</description>
    </item>
    
  </channel>
</rss>