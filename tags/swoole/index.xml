<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swoole on Garbage Collected</title>
    <link>https://guxi.me/tags/swoole/</link>
    <description>Recent content in Swoole on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2020 23:44:50 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/tags/swoole/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Interruptible Swoole Sleep</title>
      <link>https://guxi.me/posts/swoole-sleep/</link>
      <pubDate>Tue, 05 May 2020 23:44:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/swoole-sleep/</guid>
      <description>假设我们有一个监控任务，每5秒钟将监控结果上报。
&amp;lt;?php $buffer = []; // 另一个协程在填充buffer go(function() use ($buffer) { while (true) { sleep(5); sendBatch($buffer); } })   也可以使用Swoole Timer实现，这里先略过。
 那么问题来了，如果我们现在需要关闭服务，如何保证关闭前最后一批数据不丢失？
正常情况下，类unix系统，以及Kubernetes都会先给发送SIGTERM信号提示进程退出。我们的程序如果是个好好先生，就应该听从操作系统的劝告，立刻执行收尾工作并退出。如果程序拒不退出，那么操作系统可以发送强制关闭的信号。SIGINT(control-c)、SIGKILL信号这两个信号都属于“强制关闭”。
在Kuberentes下，总是先发送SIGTERM，如果在一定时间内（默认30s）进程还没有结束，就会SIGKILL。
我们要做的事，就是在收到SIGTERM时，及时把最后一批数据上报并退出。
&amp;lt;?php $exited = false; $buffer = []; $server-&amp;gt;on(&amp;#39;workerExit&amp;#39;, function() use ($exited, $buffer) { $exited = true; }); go(function() use ($exited, $buffer) { while (true) { sleep(5); sendBatch($buffer); if ($exited) { break; } } })  对上述程序这样修改，可以保证总是上报完最后一批时结束协程，然后退出。
然而细心的同学会发现这样还有两个潜在的问题。
 程序总是要完成最后一次睡眠后才退出，不是很及时。
 如果睡眠时间大于操作系统或用户容忍的时间，仍然有可能被杀掉进程丢失最后一次上报。
  事实上，我们需要的是可以中断的睡眠。当收到SIGTERM时，立刻醒来上报最后一次并退出。在传统同步编程或Callback编程中，这个不太好实现，但是在CSP编程中，可以说是一个经典Pattern。</description>
    </item>
    
    <item>
      <title>使用Hyperf插入100万行数据到MongoDB，能行吗</title>
      <link>https://guxi.me/posts/hyperf-swoole-gotask/</link>
      <pubDate>Fri, 27 Mar 2020 18:34:28 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-swoole-gotask/</guid>
      <description>得益于优秀的框架设计和超凡的性能，使用Hyperf/Swoole的开发体验非常愉悦。就比如说Hyperf的AOP切面实现吧，曾几何时我为了做jaeger分布式追踪搞了一个很复杂的动态代理，但是后来惊喜的发现在Hyperf框架中用语法树重写在不损一毫秒的情况下就轻松解决了。
不过，也有几次睡不着觉的时候，基本都是因为生态的问题。
一方面，很多C扩展，比如Mongodb，还有我们广告系统经常用的Cassandra扩展，都不能支持协程。另一方面，还有很多PHP原生库充斥着静态变量，一不小心就协程混淆。
要填补上生态上的差距还需要很长时间的努力。目前Swoole有个Task机制，不支持协程的都扔给它去处理。
 在php-fpm的应用中，经常会将一个任务异步投递到Redis等队列中，并在后台启动一些php进程异步地处理这些任务。Swoole提供的TaskWorker是一套更完整的方案，将任务的投递、队列、php任务处理进程管理合为一体。通过底层提供的API可以非常简单地实现异步任务的处理。另外TaskWorker还可以在任务执行完成后，再返回一个结果反馈到Worker。
 这个概念很好理解，Unix Socket的投递速度也是杠杠的。Task类似队列机制，本身有一种削峰填谷的功效，但是再长的缓冲区也毕竟是有限的，如果压力持续走高一样会反噬worker。所以task很难成为常规武器，偶尔用用还可以。
人一旦习惯了epoll，对阻塞IO真的是很难容忍。
有时我在想，实在不行，我就写个Nodejs服务，把查mongodb放到nodejs里，然后PHP再调nodejs接口算了，这总不阻塞了吧。
理想虽然如此，但却一直没有动手写。原因也很简单，强行把一套服务拆成两套，再搞什么限流熔断监控追踪组合拳，着实是给自己找麻烦。
算了，所以还是用Task吧。但是这个Task如果用别的语言来实现，是不是可以更快一点？
在Swoole协程普及后，Swoole的TaskWorker一般来说承担三个责任：
 遇到CPU密集型的操作，扔进来。 遇到暂时无法协程化的IO操作（如MongoDB），扔进来。 遇到某些组件不支持协程，扔进来。  前两条TaskWorker能做的，Go都可以做的更好。第三条嘛，虽然放弃了PHP生态比较遗憾，但是可以接入Go生态也不错。
最近用go搞了一个swoole的边车。是真的边车，用swoole process启动的。挂载到swoole server上跑，swoole起它起，swoole停它停，中间如果go挂了swoole还负责给拉起来。消息投递也照搬swoole task走IPC，从web worker上直接投递，等结果出来再返还web worker。
当然是0阻塞，PHP这边用swoole coroutine socket实现的，每次投递都会触发协程切换。写完再用Hyperf整了一套连接池，全局一个单例注入进来就可以IPC了。
简单示意就是这样：
package main import ( &amp;#34;github.com/reasno/gotask/pkg/gotask&amp;#34; ) // App sample type App struct{} // Hi returns greeting message. func (a *App) Hi(name interface{}, r *interface{}) error { *r = map[string]interface{}{ &amp;#34;hello&amp;#34;: name, } return nil } func main() { gotask.Register(new(App)) gotask.Run() }&amp;lt;?</description>
    </item>
    
  </channel>
</rss>