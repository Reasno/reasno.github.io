<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Garbage Collected</title>
    <link>https://guxi.me/</link>
    <description>Recent content on Garbage Collected</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2020 23:44:50 +0800</lastBuildDate>
    
	<atom:link href="https://guxi.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Interruptible Swoole Sleep</title>
      <link>https://guxi.me/posts/swoole-sleep/</link>
      <pubDate>Tue, 05 May 2020 23:44:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/swoole-sleep/</guid>
      <description>假设我们有一个监控任务，每5秒钟将监控结果上报。
&amp;lt;?php $buffer = []; // 另一个协程在填充buffer go(function() use ($buffer) { while (true) { sleep(5); sendBatch($buffer); } })   也可以使用Swoole Timer实现，这里先略过。
 那么问题来了，如果我们现在需要关闭服务，如何保证关闭前最后一批数据不丢失？
正常情况下，类unix系统，以及Kubernetes都会先给发送SIGTERM信号提示进程退出。我们的程序如果是个好好先生，就应该听从操作系统的劝告，立刻执行收尾工作并退出。如果程序拒不退出，那么操作系统可以发送强制关闭的信号。SIGINT(control-c)、SIGKILL信号这两个信号都属于“强制关闭”。
在Kuberentes下，总是先发送SIGTERM，如果在一定时间内（默认30s）进程还没有结束，就会SIGKILL。
我们要做的事，就是在收到SIGTERM时，及时把最后一批数据上报并退出。
&amp;lt;?php $exited = false; $buffer = []; $server-&amp;gt;on(&amp;#39;workerExit&amp;#39;, function() use ($exited, $buffer) { $exited = true; }); go(function() use ($exited, $buffer) { while (true) { sleep(5); sendBatch($buffer); if ($exited) { break; } } })  对上述程序这样修改，可以保证总是上报完最后一批时结束协程，然后退出。
然而细心的同学会发现这样还有两个潜在的问题。
 程序总是要完成最后一次睡眠后才退出，不是很及时。
 如果睡眠时间大于操作系统或用户容忍的时间，仍然有可能被杀掉进程丢失最后一次上报。
  事实上，我们需要的是可以中断的睡眠。当收到SIGTERM时，立刻醒来上报最后一次并退出。在传统同步编程或Callback编程中，这个不太好实现，但是在CSP编程中，可以说是一个经典Pattern。</description>
    </item>
    
    <item>
      <title>Socket.io Server For Hyperf</title>
      <link>https://guxi.me/posts/socketio-server/</link>
      <pubDate>Tue, 05 May 2020 23:27:59 +0800</pubDate>
      
      <guid>https://guxi.me/posts/socketio-server/</guid>
      <description>有小伙伴抱怨道，WebSocket Server感觉太原始，没有“框架感”。希望Socket.io协议的支持，可以让WebSocket更好用，不再有开篇提到的困惑。</description>
    </item>
    
    <item>
      <title>使用Hyperf插入100万行数据到MongoDB，能行吗</title>
      <link>https://guxi.me/posts/hyperf-swoole-gotask/</link>
      <pubDate>Fri, 27 Mar 2020 18:34:28 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-swoole-gotask/</guid>
      <description>得益于优秀的框架设计和超凡的性能，使用Hyperf/Swoole的开发体验非常愉悦。就比如说Hyperf的AOP切面实现吧，曾几何时我为了做jaeger分布式追踪搞了一个很复杂的动态代理，但是后来惊喜的发现在Hyperf框架中用语法树重写在不损一毫秒的情况下就轻松解决了。
不过，也有几次睡不着觉的时候，基本都是因为生态的问题。
一方面，很多C扩展，比如Mongodb，还有我们广告系统经常用的Cassandra扩展，都不能支持协程。另一方面，还有很多PHP原生库充斥着静态变量，一不小心就协程混淆。
要填补上生态上的差距还需要很长时间的努力。目前Swoole有个Task机制，不支持协程的都扔给它去处理。
 在php-fpm的应用中，经常会将一个任务异步投递到Redis等队列中，并在后台启动一些php进程异步地处理这些任务。Swoole提供的TaskWorker是一套更完整的方案，将任务的投递、队列、php任务处理进程管理合为一体。通过底层提供的API可以非常简单地实现异步任务的处理。另外TaskWorker还可以在任务执行完成后，再返回一个结果反馈到Worker。
 这个概念很好理解，Unix Socket的投递速度也是杠杠的。Task类似队列机制，本身有一种削峰填谷的功效，但是再长的缓冲区也毕竟是有限的，如果压力持续走高一样会反噬worker。所以task很难成为常规武器，偶尔用用还可以。
人一旦习惯了epoll，对阻塞IO真的是很难容忍。
有时我在想，实在不行，我就写个Nodejs服务，把查mongodb放到nodejs里，然后PHP再调nodejs接口算了，这总不阻塞了吧。
理想虽然如此，但却一直没有动手写。原因也很简单，强行把一套服务拆成两套，再搞什么限流熔断监控追踪组合拳，着实是给自己找麻烦。
算了，所以还是用Task吧。但是这个Task如果用别的语言来实现，是不是可以更快一点？
在Swoole协程普及后，Swoole的TaskWorker一般来说承担三个责任：
 遇到CPU密集型的操作，扔进来。 遇到暂时无法协程化的IO操作（如MongoDB），扔进来。 遇到某些组件不支持协程，扔进来。  前两条TaskWorker能做的，Go都可以做的更好。第三条嘛，虽然放弃了PHP生态比较遗憾，但是可以接入Go生态也不错。
最近用go搞了一个swoole的边车。是真的边车，用swoole process启动的。挂载到swoole server上跑，swoole起它起，swoole停它停，中间如果go挂了swoole还负责给拉起来。消息投递也照搬swoole task走IPC，从web worker上直接投递，等结果出来再返还web worker。
当然是0阻塞，PHP这边用swoole coroutine socket实现的，每次投递都会触发协程切换。写完再用Hyperf整了一套连接池，全局一个单例注入进来就可以IPC了。
简单示意就是这样：
package main import ( &amp;#34;github.com/reasno/gotask/pkg/gotask&amp;#34; ) // App sample type App struct{} // Hi returns greeting message. func (a *App) Hi(name interface{}, r *interface{}) error { *r = map[string]interface{}{ &amp;#34;hello&amp;#34;: name, } return nil } func main() { gotask.Register(new(App)) gotask.Run() }&amp;lt;?</description>
    </item>
    
    <item>
      <title>Timeout vs Deadline</title>
      <link>https://guxi.me/posts/timeout-vs-deadline/</link>
      <pubDate>Thu, 23 Jan 2020 15:23:15 +0800</pubDate>
      
      <guid>https://guxi.me/posts/timeout-vs-deadline/</guid>
      <description>One of the first few things I feel strange about gRPC is that gRPC terminate unfinished request based on a deadline mechanism instead of the more common timeout mechanism.
In pseudo-code:
var timeout = 5 * time.Second; var deadline = time.Now() + 5 * time.Second; As you can see, the deadline mechanism is less straight-forward at first glance. So why bother?
I thought this might be another &amp;ldquo;Google&amp;rdquo; thing, so I didn&amp;rsquo;t put my mind to it until recently.</description>
    </item>
    
    <item>
      <title>Why You Should Avoid Using Request-scoped Injection in NestJS</title>
      <link>https://guxi.me/posts/why-you-should-avoid-using-request-scope-injection-in-nest-js/</link>
      <pubDate>Wed, 22 Jan 2020 16:04:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/why-you-should-avoid-using-request-scope-injection-in-nest-js/</guid>
      <description>NestJS 6 comes with all-new injection scope support. Namely, instead of enforcing every object managed by DI container to be a singleton, you can now freely assign three types of injection scope to them: singleton, request, and transient.
We adopted the request-scoped injection in our project to achieve distributed tracing as well as context-aware logging. The result turned out to be not so great.
For starters, the request-scoped injection is way too expensive.</description>
    </item>
    
    <item>
      <title>云原生Hyperf骨架包</title>
      <link>https://guxi.me/posts/cloudnative-hyperf/</link>
      <pubDate>Sat, 14 Dec 2019 16:27:50 +0800</pubDate>
      
      <guid>https://guxi.me/posts/cloudnative-hyperf/</guid>
      <description>2020-01-22 日更新：现已提供Hyperf Helm chart。详见repo。
 Hyperf官方提供了容器镜像，配置选项又非常开放，将Hyperf部署于云端本身并不复杂。下面我们以Kubernetes为例，对Hyperf默认的骨架包进行一些改造，使它可以优雅的运行于Kubernetes上。本文不是Kubernetes的入门介绍，需要读者已经对Kubernetes有一定了解。
生命周期 容器在Kubernetes上启动以后，Kubernetes会对容器进行两项检查: Liveness Probe和Readiness Probe。Liveness Probe如果没有通过，容器会被重启，而Readiness Probe没有通过，则会暂时将服务从发现列表中移除。当Hyperf作为HTTP Web server启动时，我们只需要添加两条路由就行了。
&amp;lt;?php namespace App\Controller; class HealthCheckController extends AbstractController { public function liveness() { return &amp;#39;ok&amp;#39;; } public function readiness() { return &amp;#39;ok&amp;#39;; } } &amp;lt;?php // in config/Routes.php Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/liveness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@liveness&amp;#39;); Router::addRoute([&amp;#39;GET&amp;#39;, &amp;#39;HEAD&amp;#39;], &amp;#39;/readiness&amp;#39;, &amp;#39;App\Controller\HealthCheckController@readiness&amp;#39;);  在Kubernetes的deployment上配置：
livenessProbe:httpGet:path:/livenessport:9501failureThreshold:1periodSeconds:10readinessProbe:httpGet:path:/readinessport:9501failureThreshold:1periodSeconds:10 当然这里我们只是简单了返回‘ok’，显然不能真正检查出健康状况。实际的检查要考虑业务具体场景和业务依赖的资源。例如对于重数据库服务我们可以检查数据库的连接池，如果连接池已满就暂时在Readiness Probe返回状态码503。
服务在Kubernetes销毁时，Kubernetes会先发来SIGTERM信号。进程有terminationGracePeriodSeconds这么长的时间（默认60秒）来自行结束。如果到时间后还没结束，Kubernetes就会发来SIGINT信号来强制杀死进程。Swoole本身是可以正确响应SIGTERM结束服务的，正常情况下不会丢失任何运行中的连接。实际生产中，如果Swoole没有响应SIGTERM退出，很有可能是因为服务端注册的定时器没有被清理。我们可以在OnWorkerExit处清理定时器来保证顺利退出。
&amp;lt;?php // config/autoload/server.php // ... &amp;#39;callbacks&amp;#39; =&amp;gt; [ SwooleEvent::ON_BEFORE_START =&amp;gt; [Hyperf\Framework\Bootstrap\ServerStartCallback::class, &amp;#39;beforeStart&amp;#39;], SwooleEvent::ON_WORKER_START =&amp;gt; [Hyperf\Framework\Bootstrap\WorkerStartCallback::class, &amp;#39;onWorkerStart&amp;#39;], SwooleEvent::ON_PIPE_MESSAGE =&amp;gt; [Hyperf\Framework\Bootstrap\PipeMessageCallback::class, &amp;#39;onPipeMessage&amp;#39;], SwooleEvent::ON_WORKER_EXIT =&amp;gt; function () { Swoole\Timer::clearAll(); }, ], // .</description>
    </item>
    
    <item>
      <title>Hyperf 注解整洁之道</title>
      <link>https://guxi.me/posts/hyperf-clean-annotations/</link>
      <pubDate>Sat, 02 Nov 2019 21:21:14 +0800</pubDate>
      
      <guid>https://guxi.me/posts/hyperf-clean-annotations/</guid>
      <description>注解是元编程的一种。元编程从字面意思上说就是编写程序的程序。和普通编程一样，注解在给我们带来便捷的同时，如果使用不当，也有可能造成可读性、可维护性下降等问题。
在某些注解中，可能有很多配置项，比如：
//这还不是一个特别夸张的例子 @CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) 如果我们的代码里用很多这样复杂的注解，就会引发以下几个问题：
 注解中可使用的数据类型表达能力有限，比如必须用方法的字符串全名来表达方法，容易出错。 离开了IDE的帮助，长注解的可读性变得很差。（比如在GitHub上） 同样配置的注解多个地方使用，修改时要改很多地方。  这里我向大家推荐通过继承的方式配置Hyperf内的注解。
下面是一个继承CircuitBreaker（熔断器）注解的例子。
&amp;lt;?php ... /** * @Annotation * @Target({&amp;#34;METHOD&amp;#34;}) * * Shorthand for CircuitBreaker(timeout=0.05, failCounter=1, successCounter=1, fallback=&amp;#34;App\Service\UserService::searchFallback&amp;#34;) */ class FooCircuitBreakerAnnotation extends CircuitBreakerAnnotation { /** * @var float */ public $timeout = 0.05; /** * @var string */ public $fallback = UserService::class.&amp;#39;::searchFallback&amp;#39;; /** * The counter required to reset to a close state. * @var int */ public $successCounter = 1; /** * The counter required to reset to a open state.</description>
    </item>
    
    <item>
      <title>Parties in Online Advertising</title>
      <link>https://guxi.me/posts/parties-in-online-advertising/</link>
      <pubDate>Wed, 09 Oct 2019 12:58:36 +0800</pubDate>
      
      <guid>https://guxi.me/posts/parties-in-online-advertising/</guid>
      <description>I am going to give a talk highlighting elementary concepts in online advertising. It is a good time to review all the basics.
DSP Demand-side platforms receive an ad request that they must answer by a time set by the SSP or ad exchange. The time allowed can be as low as 100 ms and range up to a few seconds. DSPs decide whether they want to bid. If they do, they must select an ad, determine a bid price, and return their offer to the ad exchange.</description>
    </item>
    
    <item>
      <title>Beware of Backpressure</title>
      <link>https://guxi.me/posts/beware-of-backpressure/</link>
      <pubDate>Thu, 15 Aug 2019 22:42:25 +0800</pubDate>
      
      <guid>https://guxi.me/posts/beware-of-backpressure/</guid>
      <description>One of my junior dev was frustrated today. He was supposed to read from a file stream with NodeJS, piping that into the database. However, he got errors thrown everywhere when dealing with larger files. I helped him identified the problem. He had been dumping async calls (the database insertion) faster than the call could be handled.
I remotely remember I run into a similar issue years ago when I wrote a web scraper in NodeJS.</description>
    </item>
    
    <item>
      <title>Compress Url Parameters Without a Storage</title>
      <link>https://guxi.me/posts/compress-url-parameters-without-a-storage/</link>
      <pubDate>Tue, 13 Aug 2019 12:55:17 +0800</pubDate>
      
      <guid>https://guxi.me/posts/compress-url-parameters-without-a-storage/</guid>
      <description>&lt;p&gt;In advertising and other online marketing fields, a common practice is to distribute URLs to the clients so that they can report user action through a simple GET request.&lt;/p&gt;

&lt;p&gt;Those parameters are fake. But you got the idea. Longer URLs mean higher bandwidth consumption. Moreover, if your URL is too long, you will risk triggering &lt;strong&gt;Error 413: request entity too large&lt;/strong&gt;. I know nginx throws it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Purposed PHP Dialect: P&#43;&#43;</title>
      <link>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</link>
      <pubDate>Mon, 12 Aug 2019 08:26:23 +0800</pubDate>
      
      <guid>https://guxi.me/posts/purposed-php-dialect-p-plus-plus/</guid>
      <description>The first time I saw P++ my reaction was &amp;ldquo;meh, it is not going anywhere&amp;rdquo;. Anything breaks backward compatibility and abandons existing user base will get punished eventually. Python community took a decade to heal from the wound caused by Python3. In short, I believe it is not worth it to trade backward compatibility for language design purity. I also wrote a blog about Vue3 changes on its new functional APIs.</description>
    </item>
    
    <item>
      <title>Rethink The Clean Architecture</title>
      <link>https://guxi.me/posts/rethink-clean-architecture/</link>
      <pubDate>Sun, 11 Aug 2019 21:56:39 +0800</pubDate>
      
      <guid>https://guxi.me/posts/rethink-clean-architecture/</guid>
      <description>The Clean Architecture is more like a fantasy. It is like a wonderland we will never be in.
I would enjoy and appreciate a work where all business domains, application domains, and transports and UIs, etc. are all orthogonal. In reality, they are all wired together like a mess. It is no mess created by engineer though. The world is chaotic by itself, so do all the business around it. Imagine your boss tell your team to add a new button to your website, and you find your business rule doesn&amp;rsquo;t cover this button what so ever, so you have to update your JSON API, add new test cases, and add new event to your event sourcing bus, and change whatever is affected all the way down to the database level.</description>
    </item>
    
    <item>
      <title>Unboxing Taylor Otwell&#39;s Laravel Cloud</title>
      <link>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</link>
      <pubDate>Tue, 06 Aug 2019 21:39:20 +0800</pubDate>
      
      <guid>https://guxi.me/posts/unboxing-taylor-otwell-s-laravel-cloud/</guid>
      <description>Taylor Otwell, the author of Laravel, recently put up a public copy of his unfinished work Laravel Cloud in GitHub. It was taken down by himself briefly after, due to what he described as &amp;ldquo;too much BS&amp;rdquo;. Forks are still available everywhere though. Here is my fork.
I cloned the repository and skimmed through most of the classes. Here are my takeaways.
 Dependency Injection is used very lightly. The service container is mostly underfilled.</description>
    </item>
    
    <item>
      <title>Contextual Dependency Injection Is a Myth</title>
      <link>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</link>
      <pubDate>Mon, 05 Aug 2019 23:11:10 +0800</pubDate>
      
      <guid>https://guxi.me/posts/contextual-dependency-injection-is-a-myth/</guid>
      <description>Sometimes in your daily programming life, you would want to inject different object instances based on the current route or module. For example, you want to connect to Database Foo for route /foo and Database Bar for route /bar. It seems a clever idea to do what is called a &amp;ldquo;contextual binding&amp;rdquo;, aka inject instances conditionally based on some runtime value.
In Laravel it looks like this:
&amp;lt;?php $this-&amp;gt;app-&amp;gt;when(PhotoController::class) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;local&amp;#39;); }); $this-&amp;gt;app-&amp;gt;when([VideoController::class, UploadController::class]) -&amp;gt;needs(Filesystem::class) -&amp;gt;give(function () { return Storage::disk(&amp;#39;s3&amp;#39;); });  This code looks nice and handy at first glance, but in my experience, they are often doing more harm than any good.</description>
    </item>
    
    <item>
      <title>Kubernetes on Premise: Top 5 Fallacies (Part One)</title>
      <link>https://guxi.me/posts/kubernetes-on-premise-top-5-fallacies-part-one/</link>
      <pubDate>Mon, 29 Jul 2019 13:08:10 +0800</pubDate>
      
      <guid>https://guxi.me/posts/kubernetes-on-premise-top-5-fallacies-part-one/</guid>
      <description>As the saying goes, Kubernetes is gradually eating the world of software. In the last year, we have switched our on premise infrastructure from Docker Swarm to Kubernetes. Adopting Kubernetes on the cloud is one thing; adopting it on premise and making it production ready is quite another. Many lessons have been learned along our journey. For those who have played with Kubernetes in the vacuum, there are probably some hidden deadly trap yet to be revealed.</description>
    </item>
    
    <item>
      <title>Never Force Yourself to Learn New Skills Without a Concrete Project</title>
      <link>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</link>
      <pubDate>Sun, 28 Jul 2019 13:51:45 +0800</pubDate>
      
      <guid>https://guxi.me/posts/never-force-yourself-to-learn-new-skills-without-a-concrete-project/</guid>
      <description>As the job demand is going nowhere in a decade, a lot of new guys want to get into programming. There are numerous courses online, teaching a variety of skills in programming. There are also new shinning frameworks climbing up GitHub trending every day. I see a lot of people, typically newly graduated students, get confused. There seems to be an endless stream of knowledge to learn. How many skills are enough?</description>
    </item>
    
    <item>
      <title>Ad Server Rewrite: Goals and Non Goals</title>
      <link>https://guxi.me/posts/ad-server-rewrite-goals-and-non-goals/</link>
      <pubDate>Fri, 26 Jul 2019 10:08:36 +0800</pubDate>
      
      <guid>https://guxi.me/posts/ad-server-rewrite-goals-and-non-goals/</guid>
      <description>We have carried out the first or maybe last round of rewrite of the Juhui DSP/SSP/ADX with Typescript. A few goals and non-goals have been set for this labor-intensive process.
Goals  Strong typed. Strong API contracts. Holistic Observability with logging, tracing, and metrics. Layered Architecture and dedicated component. Testcases can be run by anyone. Stateless over stateful. Improved readability. Proper code deprecation process.  Non-Goals  Use fancy technology.</description>
    </item>
    
    <item>
      <title>Epoll and Event Loop: Just Enough You Need for Interview</title>
      <link>https://guxi.me/posts/epoll-and-event-loop-just-enough-you-need-for-interview/</link>
      <pubDate>Wed, 24 Jul 2019 14:15:03 +0800</pubDate>
      
      <guid>https://guxi.me/posts/epoll-and-event-loop-just-enough-you-need-for-interview/</guid>
      <description>The biggest challenge for intermediate developers to understand event loop is that the articles found around the web are either written for die-hard C programmers or simply too long to read. I will give a try on explaining the event loop/epoll(), and stop at a point where interviewers will be sufficiently satisfied.
The first thing should be made crystal clear is that things happen on two sides: The kernel and the userspace.</description>
    </item>
    
    <item>
      <title>Transactions Are Not Atomic</title>
      <link>https://guxi.me/posts/transactions-are-not-atomic/</link>
      <pubDate>Fri, 19 Jul 2019 19:38:06 +0800</pubDate>
      
      <guid>https://guxi.me/posts/transactions-are-not-atomic/</guid>
      <description>MySQL (InnoDB) transactions are ACID, with A for atomicity.
 An atomic transaction is an indivisible and irreducible series of database operations such that either all occur, or nothing occurs
 The atomicity here is different from the atomicity in concurrent programming.
 An operation acting on shared memory is atomic if it completes in a single step relative to other threads.
 Suppose you want to read a number from a column, add it by an offset, and write it back to the same column.</description>
    </item>
    
    <item>
      <title>When Do We Need PHP</title>
      <link>https://guxi.me/posts/when-do-we-need-php/</link>
      <pubDate>Thu, 18 Jul 2019 12:57:59 +0800</pubDate>
      
      <guid>https://guxi.me/posts/when-do-we-need-php/</guid>
      <description>When we started huijiwiki.com, PHP was the language of the choice. But it was not much a choice. MediaWiki was coded in PHP. It provided us a solid starting point to expand our idea.
Since then I have touched many languages and am moderately proficient in some of them. Among them, Go is my current favorite. Rust is the language I want to explore more.
Go as well as Rust has a very different nature compared to PHP.</description>
    </item>
    
    <item>
      <title>Realtime Query Oriented Data Structure for DMP</title>
      <link>https://guxi.me/posts/realtime-query-oriented-data-structure-for-dmp/</link>
      <pubDate>Sat, 13 Jul 2019 11:21:14 +0800</pubDate>
      
      <guid>https://guxi.me/posts/realtime-query-oriented-data-structure-for-dmp/</guid>
      <description>DMP stands for Data Management Platform, and per Wikipedia, it is a technology platform used for collecting and managing data, mainly for digital marketing purposes. To put it simply, DMP is a collection of data about user attributes.
As you might expect a DMP may contain more than millions of data. The DMP I worked on contained nearly a billion. Open source toolings such as Elasticsearch provided a good average baseline for data analytics, and reasonable response time for general-purpose querying.</description>
    </item>
    
    <item>
      <title>Binlog Decoding</title>
      <link>https://guxi.me/posts/binlog-decoding/</link>
      <pubDate>Fri, 12 Jul 2019 14:02:34 +0800</pubDate>
      
      <guid>https://guxi.me/posts/binlog-decoding/</guid>
      <description>I have to admit I am really clumsy when it comes to SQL related stuff. This is the year of 2019, and SQL is not a fancy technology to learn anymore. I managed to get away with not diving deep into SQL for a long time, but the lack of fluency in SQL bites me quite often recently.
Yesterday I was forced into a binlog trace of the production MySQL database.</description>
    </item>
    
    <item>
      <title>Id Based Throttling</title>
      <link>https://guxi.me/posts/id-based-throttling/</link>
      <pubDate>Thu, 11 Jul 2019 07:43:40 +0800</pubDate>
      
      <guid>https://guxi.me/posts/id-based-throttling/</guid>
      <description>RxJS is bonkers!
Imagine you have an unbounded stream of events. Each has a unique id. Now you want to throttle the stream based on id, ie. each id should not appear more often than X minutes.
With RxJS:
// Throttle each id in one minute. fromEvent(emitter, &amp;#39;tick&amp;#39;).pipe( groupBy((e: Event) =&amp;gt; e.getId()), flatMap(group =&amp;gt; group.pipe(throttleTime(60 * 1000))), ).subscribe( //Do your stuff ); Without RxJS:
Too much to write.</description>
    </item>
    
    <item>
      <title>Good Code Are Easy to Remove</title>
      <link>https://guxi.me/posts/good-code-are-easy-to-remove/</link>
      <pubDate>Sat, 06 Jul 2019 23:18:37 +0800</pubDate>
      
      <guid>https://guxi.me/posts/good-code-are-easy-to-remove/</guid>
      <description>Over the days I have been thinking about improving my coding one step further. As I was refactoring some company work, this idea came to me.
One of the least mentioned traits of good code is that you can easily remove a slice of them (from a larger project).
Think about that. Removability means components are modular, architecture is layered, and abstractions are aptly interfaced. It also means Single Responsibility is enforced, so removing one thing won’t jeopardize another.</description>
    </item>
    
    <item>
      <title>Options Take a Toll</title>
      <link>https://guxi.me/posts/options-take-a-toll/</link>
      <pubDate>Sun, 30 Jun 2019 16:24:33 +0800</pubDate>
      
      <guid>https://guxi.me/posts/options-take-a-toll/</guid>
      <description>Vue community exploded due to changes in Vue 3. Some comments are full of gunpowder with regards to the recent functional API RFC. Let me show my opinions up front:
 A. OSS authors clearly deserve more respect.
 B. I think functional API generally are more expressive compared to the old one.
  However I would like to provide a counter argument to a very point the defender of RFC made.</description>
    </item>
    
    <item>
      <title>Manual Injection</title>
      <link>https://guxi.me/posts/manual-injection/</link>
      <pubDate>Thu, 27 Jun 2019 21:06:28 +0800</pubDate>
      
      <guid>https://guxi.me/posts/manual-injection/</guid>
      <description>Came across this pic from twitter.
If I have an adequate number of audience, I would like to make poll out of it. What do you think about this piece of code?
 A: It is good code. B: It is bad code.  I have never done react before (Or I have, but not professional). However this piece of code is very readable to me. If I was tasked with the job to maintain this code, I would appreciate the original author for coding in this fashion.</description>
    </item>
    
    <item>
      <title>Beauty of Lazy Execution</title>
      <link>https://guxi.me/posts/beauty-of-lazy-execution/</link>
      <pubDate>Thu, 27 Jun 2019 00:17:13 +0800</pubDate>
      
      <guid>https://guxi.me/posts/beauty-of-lazy-execution/</guid>
      <description>I have done some quick&amp;rsquo;n&amp;rsquo;dirty bid data processing with Apache Beam in past weeks. As someone who try to stay away from JVM, I am not a big data expert at all. However the working with apache beam is a blast (Using JAVA!). The lazy execution style feels right a home. I love wiring a various component into a topology, and only start processing when data arrives.
I once heard a Haskell fan said that she thought lazy execution was what set Haskell apart from other programing languages.</description>
    </item>
    
    <item>
      <title>Industry on Service Mesh</title>
      <link>https://guxi.me/posts/industry-on-service-mesh/</link>
      <pubDate>Mon, 24 Jun 2019 14:11:24 +0800</pubDate>
      
      <guid>https://guxi.me/posts/industry-on-service-mesh/</guid>
      <description>Just read a thread in twitter from Matt Klein, where he basically summarized his opinion about complex tooling like service mesh. Though it is not straightforward to me that Matt, the creator of envoy, is actually dissuading people from jumping on the mesh train, his opinion is not really a fresh one. It seems to be a more and more accepted idea that service mesh are not for every body. It solves a domain of problems that only the top of the pyramid would encounter but meanwhile introduces a bunch of other headaches.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://guxi.me/posts/coding_standard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://guxi.me/posts/coding_standard/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>